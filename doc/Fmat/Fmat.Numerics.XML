<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fmat.Numerics</name></assembly>
<members>
<member name="T:AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-Reset(System.Int32)">
<summary>Resets internal random number generator to new seed
</summary>
<param name="newSeed">New seed to reset random number generator</param>
</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-NextSingleArray(System.Int32)">
<summary>Returns single precision float32 array filled with numbers between 0.0f and 1.0f
</summary>
<param name="length">Length of generated array</param>
</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-NextIntArray(System.Int32)">
<summary>Returns int array filled with nonnegative random numbers
</summary>
<param name="length">Length of generated array</param>
</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-NextIntArray(System.Int32,System.Int32)">
<summary>Returns int array filled with random numbers between 0 and (exclusive) maxValue
</summary>
<param name="length">Length of generated array</param>
<param name="maxValue">Exclusive maxValue</param>
</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-NextIntArray(System.Int32,System.Int32,System.Int32)">
<summary>Returns int array filled with random numbers between a and b
</summary>
<param name="length">Length of generated array</param>
<param name="a">Inclusive left end</param>
<param name="b">Exclusive right end</param>
</member>
<member name="M:Fmat.Numerics.DefaultGenerator.Fmat-Numerics-IRandomGenerator-NextDoubleArray(System.Int32)">
<summary>Returns double precision float array filled with numbers between 0.0 and 1.0
</summary>
<param name="length">Length of generated array</param>
</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.DefaultGenerator">
<summary>Default random number generator used by RandStream. This generator uses internally System.Random.
</summary>
<param name="seed">Initial random number generator seed</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.IRandomGenerator.Reset(System.Int32)">
<summary>Resets random number generator to new seed
</summary>
<param name="param0">New seed to reset random number generator</param>
</member>
<member name="M:Fmat.Numerics.IRandomGenerator.NextSingleArray(System.Int32)">
<summary>Generates single precision float array filled with numbers between 0.0f and 1.0f
</summary>
<param name="param0">Length of generated array</param>
<returns>Float32 array filled with random numbers between a and b</returns>
</member>
<member name="M:Fmat.Numerics.IRandomGenerator.NextIntArray(System.Int32)">
<summary>Generates int array filled with nonnegative random numbers
</summary>
<param name="param0">Length of generated array</param>
<returns>Int array filled with random numbers between a and b</returns>
</member>
<member name="M:Fmat.Numerics.IRandomGenerator.NextIntArray(System.Int32,System.Int32)">
<summary>Generates int array filled with random numbers between 0 and (exclusive) maxValue
</summary>
<param name="param0">Length of generated array</param>
<param name="param1">Exclusive maxValue</param>
<returns>Int array filled with random numbers between a and b</returns>
</member>
<member name="M:Fmat.Numerics.IRandomGenerator.NextIntArray(System.Int32,System.Int32,System.Int32)">
<summary>Generates int array filled with random numbers between a and b
</summary>
<param name="param0">Length of generated array</param>
<param name="param1">Inclusive left end</param>
<param name="param2">Exclusive right end</param>
<returns>Int array filled with random numbers between a and b</returns>
</member>
<member name="M:Fmat.Numerics.IRandomGenerator.NextDoubleArray(System.Int32)">
<summary>Generates double precision float array filled with numbers between 0.0 and 1.0
</summary>
<param name="param0">Length of generated array</param>
<returns>Float array filled with random numbers between a and b</returns>
</member>
<member name="T:Fmat.Numerics.IRandomGenerator">
<summary>Interface for types which implement random number generation. Instances can be plugged into RandStream
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.Matrix`2.zeros(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic zero
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix.zeros [2;3;4] : Matrix
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.vertConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{`0,`1}})">
<summary>Concatenates matrices along dimension 0
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;2;5 : Matrix
let x2 = rand [3;2;5]
let x3 = rand [4;2;5]
let y = Matrix.vertConcat([x1;x2;x3]) // returns matrix 9x2x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.var(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates variance of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which variance will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.var(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.unifRnd(`0,`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [a, b] 
</summary>
<param name="a">Lower endpoint</param>
<param name="b">Upper endpoint</param>
<param name="size">Dimensions of the matrix to be generated</param>
<returns>Matrix with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.unifRnd(0.0, 1.0, [2;3;4])
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or b &lt;= a.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.triU(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Extracts upper triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="offset">Offset. Specifies which diagonal should be included</param>
<returns>Upper triangular matrix down to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = Matrix.triU(x, -1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.triL(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Extracts lower triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="offset">Offset. Specifies which diagonal should be included</param>
<returns>Lower triangular matrix up to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = Matrix.triL(x, 1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.transpose(Fmat.Numerics.Matrix{`0,`1})">
<summary>Transposes matrix
</summary>
<param name="matrix">Input matrix</param>
<returns>Transposed matrix. Input matrix does not change</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = Matrix.transpose(x) // returns matrix 4x3
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.svdSolve(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Finds least squares solution of linear equation using singular value factorization with given tolerance
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<param name="tol">Tolerance to determine rank of A.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let a = rand [2;2]
let b = rand [2;1]
let x = Matrix.svdSolve(a, b, 1e-10)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Try different tolerance.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.svd(Fmat.Numerics.Matrix{`0,`1})">
<summary>Performs singular value factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(U, S, Vt) matrices, S is vector of singular values, Vt is transposed V </returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [20;10]
let (u, s, vt) = Matrix.svd(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when algorithm did not converge.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.sum(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which sum will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.sum(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.skewness(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates skewness of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which skewness will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.skewness(x, 1) // returns Matrix with size [2;1;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.MaxDisplaySize(System.Int32[])">
<summary>Gets or sets maximum number of elements in each dimension to display when calling Matrix.ToString()
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.MatrixFunctions
let x = ones [10;10]
Matrix.MaxDisplaySize &lt;- [|2;3;4|] // show first 2 rows, 3 columns and 4 pages
let s = x.ToString() 
</code>
</example>
<remarks>Default value is 10 in each dimension, [|2;3;4|] is equivalent to [|2;3;4;4;4;4;4...|]
</remarks>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},`0)">
<summary>Gets or sets submatrix using boolean indexing based on given function
</summary>
<param name="predicate">Boolean function which specifies which elements to get or set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
x.[fun x -&gt; x*x &lt; 2.0] &lt;- 1.0 // sets elements to 1.0 where square of element value is less than 2.0
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(Fmat.Numerics.__BoolMatrix,`0)">
<summary>Gets or sets submatrix using boolean indexing
</summary>
<param name="boolMatrix">Boolean matrix. Specifies which elements to get or set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
x.[x .&gt; 0.5] &lt;- 1.0 // sets elements to 1.0 where element value is greater than 0.5
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.ArgumentException">Thrown when boolean matrix dimensions do not match matrix dimensions.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="s3">4th dimension sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4;4] 
x.[[0;2], [1;3], [0;1], [2;3]] &lt;- ones [2;2;2;2] // sets specified elements to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4] : Matrix
x.[[0;2], [1;3], [0;1]] &lt;- ones [2;2;2] // sets elements in rows 0 and 2 and columns 1 and 3 and page 0 and 1 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.[[0;2], [1;3]] &lt;- ones [2;2] // sets elements in rows 0 and 2 and columns 1 and 3 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32}[],Fmat.Numerics.Matrix{`0,`1})">
<summary>Gets or sets submatrix
</summary>
<param name="indexSeqs">ParamArray of subscript sequences</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
let y = x.[[0;2],[1;3]] // gets elements in rows 0 and 2 and columns 1 and 3 
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Gets or sets submatrix using linear indexing in column major order
</summary>
<param name="indices">Sequence of subscripts</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3;4] : Matrix
let y = x.[{0L..2..4}] // gets 1st, 3rd and 5th element as row vector
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when non matching length of value matrix.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32,System.Int32,System.Int32,`0)">
<summary>Sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<param name="k">Third subscript: page</param>
<param name="l">4th subscript</param>
<param name="value">Value to set</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3;4] : Matrix
x.[0, 1, 2, 3] &lt;- 0.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32,System.Int32,`0)">
<summary>Sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<param name="k">Third subscript: page</param>
<param name="value">Value to set</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3] : Matrix
x.[0, 1, 2] &lt;- 0.0// sets element in first row second column and third page to zero
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32,`0)">
<summary>Sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<param name="value">Value to set</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
x.[0, 1] &lt;- 0.0// sets element in first row and second column to zero
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32[],`0)">
<summary>Gets or sets matrix element
</summary>
<param name="indices">Array of subscripts, each for one matrix dimension</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.[ [|0; 1|] ] // returns element in first row and second column
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of indices.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,`0)">
<summary>Gets or sets matrix element
</summary>
<param name="i">Linear index in column major order.</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[1] // returns second element in matrix using column major order
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.DisplayFormat(System.String)">
<summary>Gets or sets format used to display matrix elements when ToString() is called. 
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
Matrix.DisplayFormat &lt;- "G5" // show 5 digits
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.DisplayDigits(System.Int32)">
<summary>Sets display format for given matrix type to Gn where n equals display digits 
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
Matrix.DisplayDigits &lt;- 5 // show 5 digits
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.reshape(Fmat.Numerics.Matrix{`0,`1},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Reshapes matrix. Number of elements must not change.
</summary>
<param name="matrix">Input matrix</param>
<param name="size">New size</param>
<returns>Reshaped matrix. Input matrix is not changed</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = Matrix.reshape(x, [3;2;2]) // returns matrix 3x2x2
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when new size is invalid or length is different.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.repmat(Fmat.Numerics.Matrix{`0,`1},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Replicates matrix in each dimension
</summary>
<param name="matrix">Input matrix</param>
<param name="replicator">Array of replicators, one for each dimension</param>
<returns>Replicated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;5] : Matrix
let y = Matrix.repmat(x, [2;3;1] // returns matrix 4x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when replicator has less than 2 elements or negative element.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.quantile(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates quantiles of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="q">Quantiles vector:  Matrix 1xn or nx1</param>
<param name="dim">Dimension along which quantiles will be calculated</param>
<returns>matrix with quantiles</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;30;4] : Matrix
let q = Matrix([0.05;0.95])
let y = Matrix.quantile(x, q, 1) // returns Matrix with size [2;2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified or quantile q not in 0&lt;=q&lt;=1.</exception>
<exception cref="T:System.RankException">Thrown when quantiles not a vector 1xn or nx1.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.qrSolveFull(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Finds least squares solution of linear equation using QR factorization assuming full rank
</summary>
<param name="a">A in equation Ax=b. Must have full rank</param>
<param name="b">b in equation Ax=b.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let a = rand [2;2]
let b = rand [2;1]
let x = Matrix.qrSolveFull(a, b)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Matrix does not have full rank</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.qr(Fmat.Numerics.Matrix{`0,`1})">
<summary>Performs QR factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(Q, R) matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [20;10]
let (q, r) = Matrix.qr(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when factorization failed.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.prod(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which product will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.prod(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.poissRnd(`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Poisson distributed random numbers
</summary>
<param name="lambda">Lambda</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.poissRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or lambda negative.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_UnaryNegation(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates minus matrix
</summary>
<param name="matrix">Matrix argument</param>
<returns>Matrix with "-" applied elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = -x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_TwiddleTwiddle(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "NOT" for bool matrix
</summary>
<param name="matrix">Bool matrix</param>
<returns>Result of elementwise "NOT"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let y = ~x // returns bool matrix [false;true;false]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Subtraction(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Subtracts matrix from a matrix elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Matrix subtracted from matrix elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
 let x2 = rand [2;3;4]
let y = x1 - x2
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Subtraction(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Subtracts scalar value from a matrix elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar subtracted from matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x - 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Subtraction(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Subtracts matrix from a scalar elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix subtracted from scalar</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 - x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Multiply(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Multiplies 2D matrix by 2D matrix
</summary>
<param name="matrix1">First 2D matrix</param>
<param name="matrix2">Second 2D matrix</param>
<returns>Matrix multiplied by matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3] : Matrix
let x1 = rand [3;4]
let y = x1 * x2 // return matrix 2x4 
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Multiply(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Multiplies matrix by a scalar value
</summary>
<param name="a">Scalar argument</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix multiplied by a value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x * 2.0 
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Multiply(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Multiplies matrix by a scalar value
</summary>
<param name="a">Scalar argument</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix multiplied by a value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 * x 
</code>
</example>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Explicit(Fmat.Numerics.Matrix{`0,`1})">
<summary>Casts matrix to underlying element type matrix is scalar 1x1
</summary>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_EqualsEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if matrix is a scalar matrix equal to given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">scalar value</param>
<returns>True if the same value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix(2.0) // scalar matrix
let a = 2.0
let y = a == x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_EqualsEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if matrix is a scalar matrix equal to given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">scalar value</param>
<returns>True if the same value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix(2.0) // scalar matrix
let a = 2.0
let y = x == a // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_EqualsEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if 2 matrix instances hold identical values
</summary>
<param name="matrix1">First matrix to compare</param>
<param name="matrix2">Second matrix to compare</param>
<returns>True if matrices have the same size and the same values in all cells</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1 == x2 // returns boolean
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotPlus(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Adds scalar value to a matrix
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar added to a matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x .+ 2.0 
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotPlus(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Adds scalar value to a matrix
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar added to a matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 .+ x  
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotPlus(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Adds matrices elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Added matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x1 = rand [2;3;4]
let y = x1 .+ x2  
</code>
</example>  
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMultiply(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Multiplies matrices elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Multiplied matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x1 = rand [2;3;4]
let y = x1 .* x2  
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMultiply(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Multiplies matrix by scalar value elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix multiplied by scalar elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x .* 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMultiply(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Multiplies scalar value by a matrix elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix multiplied by scalar elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 .* x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMinus(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Subtracts matrix from a matrix elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Matrix subtracted from matrix elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
 let x2 = rand [2;3;4]
let y = x1 .- x2
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMinus(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Subtracts scalar value from a matrix elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar subtracted from matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x .- 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotMinus(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Subtracts matrix from a scalar elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix subtracted from scalar</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 .- x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessGreater(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "not equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .&lt;&gt; x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessGreater(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "not equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .&lt;&gt; x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessGreater(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "not equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .&lt;&gt; 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "less than or equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .&lt;= x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "less than or equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .&lt;= x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLessEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "less than or equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .&lt;= 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLess(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "less than" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .&lt; x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLess(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "less than" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .&lt; x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotLess(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "less than" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Value to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .&lt; 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotHat(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise scalar power matrix
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Power</param>
<returns>Elementwise power of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 .^ x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreaterEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "greater than or equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .&gt;= x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreaterEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "greater than or equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .&gt;= x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreaterEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "greater than or equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .&gt;= 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreater(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "greater than" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .&gt; x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreater(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "greater than" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .&gt; x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotGreater(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "greater than" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .&gt; 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEqualsEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "equal equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .== x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEqualsEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "equal equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .== x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEqualsEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "equal equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .== 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .= x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .= x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .= 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotDivide(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Divides scalar by matrix elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar divided by matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 ./ x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotDivide(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Divides matrix by scalar value elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix divided by scalar</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x ./ 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotDivide(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Divides matrix by matrix elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Matrix divided by another matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BAsicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1 ./ x2
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBarBar(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "OR" for bool matrix and scalar value
</summary>
<param name="matrix">Bool matrix</param>
<param name="a">Scalar value</param>
<returns>Result of elementwise "OR"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let a = true
let z = a .&amp;&amp; x // returns bool matrix [true;true;true]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBarBar(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Calculates elementwise "AND" for bool matrix and scalar value
</summary>
<param name="matrix">Bool matrix</param>
<param name="a">Scalar value</param>
<returns>Result of elementwise "AND"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let a = true
let z = x .|| a // returns bool matrix [true;true;true]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBarBar(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "OR" for bool matrices
</summary>
<param name="matrix1">First bool matrix</param>
<param name="matrix2">Second bool matrix</param>
<returns>Result of elementwise "OR"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let x = BoolMatrix([true;false;false])
let z = x .|| y // returns bool matrix [true;false;true]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrices do not have matching sizes.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBangEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "not equal" operator to matrices (including scalar matrices 1x1)
</summary>
<param name="matrix1">First matrix to compare. </param>
<param name="matrix2">Second matrix to compare</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1.[x1 .!= x2] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBangEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Applies elementwise "not equal" operator to a value and matrix
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[0.5 .!= x] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotBangEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Applies elementwise "not equal" operator to matrix and a value
</summary>
<param name="matrix">Matrix to be compared</param>
<param name="a">Number to compare matrix elements with</param>
<returns>Boolean matrix with result of elementwise comparison</returns>
<remarks>You can use boolean matrix result in matrix indexing:
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[x .!= 0.5] // returns vector
</code>
</example>
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotAmpAmp(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "AND" for bool matrix and scalar value
</summary>
<param name="matrix">Bool matrix</param>
<param name="a">Scalar value</param>
<returns>Result of elementwise "AND"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let a = true
let z = a .&amp;&amp; x // returns bool matrix [true;false;true]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotAmpAmp(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Calculates elementwise "AND" for bool matrix and scalar value
</summary>
<param name="matrix">Bool matrix</param>
<param name="a">Scalar value</param>
<returns>Result of elementwise "AND"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let a = true
let z = x .&amp;&amp; a // returns bool matrix [true;false;true]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_DotAmpAmp(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "AND" for bool matrices
</summary>
<param name="matrix1">First bool matrix</param>
<param name="matrix2">Second bool matrix</param>
<returns>Result of elementwise "AND"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let x = BoolMatrix([true;false;false])
let z = x .&amp;&amp; y // returns bool matrix [true;false;false]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrices do not have matching sizes.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Division(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Divides scalar by matrix elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar divided by matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 / x
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Division(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Divides matrix by scalar value elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Matrix divided by scalar</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x / 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_BangEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if matrix is a scalar matrix not equal to given value
</summary>
<param name="a">scalar value</param>
<param name="matrix">Matrix to compare</param>
<returns>True if the same value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix(2.0) // scalar matrix
let a = 1.0
let y = a != x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_BangEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if matrix is a scalar matrix not equal to given value
</summary>
<param name="a">scalar value</param>
<param name="matrix">Matrix to compare</param>
<returns>True if the same value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix(2.0) // scalar matrix
let a = 1.0
let y = x != a // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_BangEquals(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if 2 matrix instances hold different value
</summary>
<param name="matrix1">First matrix to compare</param>
<param name="matrix2">Second matrix to compare</param>
<returns>True if matrices have different size or at least one different value in a cell</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x2 = rand [2;3;4]
let y = x1 != x2 // returns boolean
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLessGreater(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are not equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are not equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics.Math
let x = ones [2;3]
let y = 1.0 &amp;&lt;&gt; x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLessGreater(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are not equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;&lt;&gt; 2.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLessEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are greater than equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are greater than equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = 1.0 &amp;&lt;= x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLessEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are less than equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are less than equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;&lt;= 1.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLess(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are greater than given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are greater than given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = 2.0 &amp;&lt; x // returns false
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpLess(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are less than given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are less than given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;&lt; 2.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpGreaterEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are less than equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are less than equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = 1.0 &amp;&gt;= x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpGreaterEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are greater than equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are greater than equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;&gt;= 1.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpGreater(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are less than given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are less than given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = 1.0 &amp;&gt; x // returns false
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpGreater(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are greater than given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are greater than given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;&gt; 1.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = 1.0 &amp;= x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;= 1.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpBangEquals(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Checks if all matrix elements are not equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are not equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics.Math
let x = ones [2;3]
let y = 1.0 &amp;!= x // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_AmpBangEquals(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Checks if all matrix elements are not equal given value
</summary>
<param name="matrix">Matrix to compare</param>
<param name="a">Value</param>
<returns>True if all matrix elements are equal given value</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = ones [2;3]
let y = x &amp;!= 2.0 // returns true
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Addition(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Adds matrix to a scalar value elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar added to a matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x + 2.0  
</code>
</example>  
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Addition(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Adds matrix to a scalar value elementwise
</summary>
<param name="a">Scalar value</param>
<param name="matrix">Matrix argument</param>
<returns>Scalar added to a matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = 2.0 + x  
</code>
</example>  
</member>
<member name="M:Fmat.Numerics.Matrix`2.op_Addition(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Adds matrices elementwise
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Added matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [2;3;4] : Matrix
let x1 = rand [2;3;4]
let y = x1 + x2  
</code>
</example>  
</member>
<member name="M:Fmat.Numerics.Matrix`2.ones(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic one
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix with all elements equal one</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix.ones [2;3;4] : Matrix
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.not(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise "NOT" for bool matrix
</summary>
<param name="matrix">Bool matrix</param>
<returns>Result of elementwise "NOT"</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = BoolMatrix([true;false;true])
let y = ~x // returns bool matrix [false;true;false]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.normalRnd(`0,`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with normal random numbers
</summary>
<param name="mean">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.normRnd(0.0, 1.0, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.mvNormRnd(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Generates matrix with multivariate normal distribution
</summary>
<param name="mean">Vector kx1 or 1xk of means</param>
<param name="cov">Covariance matrix kxk</param>
<param name="n">Number of k-dimensional vectors to generate. Vectors are returned in rows of result matrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let mn = !![2.345;2.345]
let cv = !![ [1.;1.]
             [1.;2.] ]
let m = Matrix.mvNormRnd(mn, cv, 10) // returns matrix 10x2 
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or cov matrix not pos definite or incompatible size.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.minXY(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise minimum of matrix and scalar
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Scalar argument</param>
<returns>Elementwise minimum</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4]
let a = 0.5
let z = Matrix.minXY(a, x)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.minXY(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Calculates elementwise minimum of matrix and scalar
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Scalar argument</param>
<returns>Elementwise minimum</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4]
let a = 0.5
let z = Matrix.minXY(x, a)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.minXY(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise minimum of matrices.
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Elementwise minimum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = rand [2;3;4]
let z = Matrix.minXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.min(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.min(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.mean(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates mean of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which mean will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.mean(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.maxXY(`0,Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise maximum of matrix and scalar
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Scalar argument</param>
<returns>Elementwise maximum</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4]
let a = 0.5
let z = Matrix.maxXY(a, x)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.maxXY(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Calculates elementwise maximum of matrix and scalar
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Scalar argument</param>
<returns>Elementwise maximum</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4]
let a = 0.5
let z = Matrix.maxXY(x, a)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.maxXY(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise maximum of matrices.
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<returns>Elementwise minimum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = rand [2;3;4]
let z = Matrix.maxXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.max(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.max(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.luSolve(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Solves linear equation using LU factorization
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let a = rand [2;2]
let b = rand [2;1]
let x = Matrix.luSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D square or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.lu(Fmat.Numerics.Matrix{`0,`1})">
<summary>Performs LU factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(L, U, P) Lower/Upper matrices, P is a vector with row permutations</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [20;10]
let (l, u, p) = Matrix.lu(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.lognormRnd(`0,`0,`0,`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with lognormal random numbers
</summary>
<param name="mean">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="a">Displacement</param>
<param name="scale">Scale</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.lognormRnd(0.0, 1.0, 0.0, 1.0, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.kurtosis(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates kurtosis of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which kurtosis will be calculated</param>
<returns>matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.kurtosis(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.horzConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{`0,`1}})">
<summary>Concatenates matrices along dimension 1
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [3;2;5] : Matrix
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = Matrix.horzConcat([x1;x2;x3]) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.T">
<summary>Returns transposed matrix as new instance. Original instance is not affected. 
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.T // new instance matrix [3;2]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Size">
<summary>Gets size of the matrix (each dimension length)
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let size = x.Size // returns [|2;3;4|]
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.NDims">
<summary>Gets number of dimensions
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let dims = x.NDims //returns 3
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.MaxDisplaySize">
<summary>Gets or sets maximum number of elements in each dimension to display when calling Matrix.ToString()
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.MatrixFunctions
let x = ones [10;10]
Matrix.MaxDisplaySize &lt;- [|2;3;4|] // show first 2 rows, 3 columns and 4 pages
let s = x.ToString() 
</code>
</example>
<remarks>Default value is 10 in each dimension, [|2;3;4|] is equivalent to [|2;3;4;4;4;4;4...|]
</remarks>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Length">
<summary>Gets total number of elements/cells in matrix
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let len = x.Length //returns 24
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>Gets or sets submatrix using boolean indexing based on given function
</summary>
<param name="predicate">Boolean function which specifies which elements to get or set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
x.[fun x -&gt; x*x &lt; 2.0] &lt;- 1.0 // sets elements to 1.0 where square of element value is less than 2.0
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(Fmat.Numerics.__BoolMatrix)">
<summary>Gets or sets submatrix using boolean indexing
</summary>
<param name="boolMatrix">Boolean matrix. Specifies which elements to get or set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
x.[x .&gt; 0.5] &lt;- 1.0 // sets elements to 1.0 where element value is greater than 0.5
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.ArgumentException">Thrown when boolean matrix dimensions do not match matrix dimensions.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="s3">4th dimension sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4;4] 
x.[[0;2], [1;3], [0;1], [2;3]] &lt;- ones [2;2;2;2] // sets specified elements to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4] : Matrix
x.[[0;2], [1;3], [0;1]] &lt;- ones [2;2;2] // sets elements in rows 0 and 2 and columns 1 and 3 and page 0 and 1 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Gets or sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.[[0;2], [1;3]] &lt;- ones [2;2] // sets elements in rows 0 and 2 and columns 1 and 3 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32}[])">
<summary>Gets or sets submatrix
</summary>
<param name="indexSeqs">ParamArray of subscript sequences</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
let y = x.[[0;2],[1;3]] // gets elements in rows 0 and 2 and columns 1 and 3 
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
<exception cref="T:System.ArgumentException">Thrown when value does not match submatrix shape.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Gets or sets submatrix using linear indexing in column major order
</summary>
<param name="indices">Sequence of subscripts</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3;4] : Matrix
let y = x.[{0L..2..4}] // gets 1st, 3rd and 5th element as row vector
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when non matching length of value matrix.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>Gets or sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<param name="k">Third subscript: page</param>
<param name="k">4th dimension subscript</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3;4] : Matrix
let y = x.[1, 1, 2, 3]
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32,System.Int32)">
<summary>Gets or sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<param name="k">Third subscript: page</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3] : Matrix
let y = x.[1, 1, 2]
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32,System.Int32)">
<summary>Gets or sets matrix element
</summary>
<param name="i">First subscript: row</param>
<param name="j">Second subscript: column</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.[1, 1]
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32[])">
<summary>Gets or sets matrix element
</summary>
<param name="indices">Array of subscripts, each for one matrix dimension</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.[ [|0; 1|] ] // returns element in first row and second column
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of indices.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Item(System.Int32)">
<summary>Gets or sets matrix element
</summary>
<param name="i">Linear index in column major order.</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x.[1] // returns second element in matrix using column major order
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="P:Fmat.Numerics.Matrix`2.IsVector">
<summary>Checks if matrix is 1xn or nx1
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [1;3]
let x.IsVector // returns true
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.IsScalar">
<summary>Checks if matrix is scalar 1x1
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [1;1]
let x.IsScalar // returns true
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Empty">
<summary>Get instance of matrix with zero elements
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix.Empty
let y = x.Length // returns 0
let y = x.Size // returns [|0;0|]
</code>
</example> 
</member>
<member name="P:Fmat.Numerics.Matrix`2.DisplayFormat">
<summary>Gets or sets format used to display matrix elements when ToString() is called. 
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
Matrix.DisplayFormat &lt;- "G5" // show 5 digits
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.DisplayDigits">
<summary>Sets display format for given matrix type to Gn where n equals display digits 
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
Matrix.DisplayDigits &lt;- 5 // show 5 digits
</code>
</example>
</member>
<member name="P:Fmat.Numerics.Matrix`2.Diag(Microsoft.FSharp.Core.FSharpOption{System.Object})">
<summary>Gets matrix k-th diagonal as new matrix instance. If k not specified then main diag (k=0)
</summary>
<param name="k">Diagonal offset (optional)</param>
<returns>k-th diagonal
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.Diag(-1)
let z = x.Diag()
</code>
</example>   
<exception cref="T:System.RankException">Thrown when matrix is not 2D.</exception>   
</member>
<member name="P:Fmat.Numerics.Matrix`2.Data">
<summary>Returns matrix data in column major order
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;2], [1.0..4.0])
let data = x.Data
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.diag(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Creates diagonal matrix based on given vector (matrix 1xN or Nx1)
</summary>
<param name="matrix">Values to store in diagonal</param>
<param name="offset">Offset. Positive to store values above main digonal</param>
<returns>Matrix with k-th diagonal set to given vector</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let v = Matrix([1.;2.;3.])
let x = Matrix.diag(x, 1)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when offset too big.</exception>
<exception cref="T:System.RankException">Thrown when not vector.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.cumsum(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates cumulative sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative sum will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.cumsum(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.cumprod(Fmat.Numerics.Matrix{`0,`1},System.Int32)">
<summary>Calculates cumulative product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative product will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = Matrix.cumprod(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
<exception cref="T:System.OutOfMemoryException">Thrown when not enough memory available.</exception>
<exception cref="T:System.ObjectDisposedException">Thrown when matrix has been disposed with Dispose().</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.cov(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates covariance between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<returns>Covariance matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = Matrix.cov(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.corr(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates correlation between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<returns>Correlation matrix pxp</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = Matrix.corr(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.concat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{`0,`1}},System.Int32)">
<summary>Concatenates matrices along given dimension
</summary>
<param name="matrices">Sequence of matrices</param>
<param name="dim">Dimension</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [3;2;5] : Matrix
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = Matrix.concat([x1;x2;x3], 1) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.cholSolve(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Solves linear equation using chol factorization
</summary>
<param name="a">A in equation Ax=b. Must be positive definite.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let a = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let b = rand [2;1]
let x = Matrix.cholSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not square or A and B have non compatible dimensions.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix A not positive definite.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.chol(Fmat.Numerics.Matrix{`0,`1})">
<summary>Performs cholesky factorization
</summary>
<param name="matrix">Input matrix. Must be positive definite.</param>
<returns>Upper triangular matrix calculated in factorization</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let y = Matrix.chol(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix not positive definite.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.binomRnd(System.Int32,`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with binomial distributed random numbers
</summary>
<param name="n">Number of trials</param>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.binomRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1 or n &lt;0.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.bernRnd(`0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Bernoulli distributed random numbers
</summary>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix.bernRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.applyFun3Arg(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,`0}}})">
<summary>Applies given function elementwise to 3 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<param name="matrix3">Third matrix</param>
<param name="f">Elementwise function of 3 args</param>
<returns>New matrix as elementwise transformation of 3 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [3;4] : Matrix
let x2 = rand [3;4]
let x3 = rand [3;4]
let y = Matrix.applyFun3Arg(x1, x2, x3, fun x1 x2 x3 -&gt; x1 + x2 + x3)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.applyFun2Arg(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1},Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`0,`0}})">
<summary>Applies given function elementwise to 2 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="matrix1">First matrix</param>
<param name="matrix2">Second matrix</param>
<param name="f">Elementwise function of 2 args</param>
<returns>New matrix as elementwise transformation of 2 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = rand [3;4] : Matrix
let x2 = rand [3;4]
let y = Matrix.applyFun2Arg(x1, x2, fun x1 x2 -&gt; x1 + x2)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.applyFun(Fmat.Numerics.Matrix{`0,`1},Microsoft.FSharp.Core.FSharpFunc{`0,`0})">
<summary>Applies given function elementwise to a matrix. New matrix is returned. Input matrix is not modified.
</summary>
<param name="matrix">Input matrix</param>
<param name="f">Elementwise function</param>
<returns>New matrix as elementwise transformation of input matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = Matrix.applyFun(x, fun x -&gt; x + 1.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Transpose">
<summary>Transposes matrix in place
</summary>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
x.Transpose()
let size = x.Size // returns [3;2]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.Matrix`2.ToString">
<summary>Converts matrix to string for display. 
</summary>
<returns>String representation of 2D or 3D matrix
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.ToString()
</code>
</example>
<remarks>
2D matrix will be displayed as rows/columns. 3D matrix will be displayed by page. For 4D and higher use matrix slicing.
Use MatrixOptions.MaxDisplaySize to specify maximum number of columns/rows/pages to display.
Use MatrixOptions.DisplayDigits to specify number of digits to display.
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.ToColMajorSeq">
<summary>Converts matrix to IEnumerable sequence of elements in column major order
</summary>
<returns>Matrix data as sequence of elements in column major order
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3]
let y = x.ToColMajorSeq() // returns seq of float
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.Tanh(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise tanh
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = tanh(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Tan(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise tan
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = tan(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Sqrt(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise square root
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = sqrt(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Sinh(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise sinh
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = sinh(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Sin(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise sin
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = sin(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},`0)">
<summary>Sets slice of 4D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<param name="start3">Start subscript in 4th dimension. Zero if not specified</param>
<param name="end3">End subscript in 4th dimension. (Length-1) if not specified</param>
<param name="value">New value</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6;5;4] : Matrix
x.[1..2, 2..3, 2..4, 0..2] &lt;- 1.0
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 4D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets slice of 4D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<param name="start3">Start subscript in 4th dimension. Zero if not specified</param>
<param name="end3">End subscript in 4th dimension. (Length-1) if not specified</param>
<param name="value">Matrix of new values</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6;5;4] : Matrix
x.[1..2, 2..3, 2..4, 0..2] &lt;- ones [2;2;3;3] 
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when value has wrong shape.</exception>
<exception cref="T:System.RankException">Thrown when matrix or value not 4D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},`0)">
<summary>Sets slice of 3D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<param name="value">New value</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6;5] : Matrix
x.[1..2, 2..3, 2..4] &lt;- 1.0
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 3D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets slice of 3D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<param name="value">Matrix of new values</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6;5] : Matrix
x.[1..2, 2..3, 2..4] &lt;- ones [2;2;3] 
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when value has wrong shape.</exception>
<exception cref="T:System.RankException">Thrown when matrix or value not 3D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},`0)">
<summary>Sets slice of 2D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="value">New value</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6] : Matrix
x.[1..2, 2..3] &lt;- 1.0
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets slice of 2D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="value">Matrix of new values</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;6] : Matrix
x.[1..2, 2..3] &lt;- ones [2;2] 
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when value has wrong shape.</exception>
<exception cref="T:System.RankException">Thrown when matrix or value not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},`0)">
<summary>Sets slice of matrix using linear indexing
</summary>
<param name="start">Start linear subscript. Zero if not specified</param>
<param name="finish">End linear subscript. (Length-1) if not specified</param>
<param name="value">New value</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
x.[0..2] &lt;- 1.0 // sets first 3 elements to 1
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or finish out of range.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.SetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets slice of matrix using linear indexing
</summary>
<param name="start">Start linear subscript. Zero if not specified</param>
<param name="finish">End linear subscript. (Length-1) if not specified</param>
<param name="value">Vector of new values</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
x.[0..2] &lt;- !![1;2;3] // sets first 3 elements to 1 2 3
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or finish out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when length of value not compatible with start and finish indices.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets submatrix using boolean indexing based on given function
</summary>
<param name="predicate">Boolean function which specifies which elements to set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = Matrix([1.;2.;3.])
x.Set(fun x -&gt; x &gt; 1.0 , Matrix([0.;1.])) // sets elements to 0 and 1 where x is greater than 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.ArgumentException">Thrown when length of value matrix not equal number of true elements in boolean matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(Fmat.Numerics.__BoolMatrix,Fmat.Numerics.Matrix{`0,`1})">
<summary>Sets submatrix using boolean indexing
</summary>
<param name="boolMatrix">Boolean matrix. Specifies which elements to get or set</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x1 = !![[1.;2.;3.]]
let x2 = !![[3.;2.;1.]] 
let bMatrix = x1 .&gt;= x2
x1.Set(bMatrix, !![[0.;1.]]) // sets elements to 0 and 1 where x1 is greater or equal x2
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.ArgumentException">Thrown when boolean matrix dimensions do not match matrix dimensions.</exception>
<exception cref="T:System.ArgumentException">Thrown when length of value matrix not equal number of true elements in boolean matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},`0)">
<summary>Sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="s3">4th dimension sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4;4] 
x.Set([0;2], [1;3], [0;1], [2;3], 1.0) // sets specified elements to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},`0)">
<summary>Sets submatrix
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="s2">Page subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4;4] 
x.Set([0;2], [1;3], [0;1], 1.0) // sets elements in rows 0 and 2 and columns 1 and 3 and page 0 and 1 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},`0)">
<summary>Sets submatrix to scalar
</summary>
<param name="s0">Row subscript sequence</param>
<param name="s1">Column subscript sequence</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.Set([0;2], [1;3], 1.0) // sets elements in rows 0 and 2 and columns 1 and 3 to 1.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{System.Int32}},`0)">
<summary>Sets submatrix to scalar value
</summary>
<param name="indexSeqs">Seq of subscript lists. If only 1 sequence then linear indexing used</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.Set([ [0..2];[1..3] ] , 3.0) 
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Int32[]},`0)">
<summary>Sets submatrix to scalar value
</summary>
<param name="indexSeqs">Seq of subscript arrays. If only 1 sequence then linear indexing used</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.Set([ [|0..2|];[|1..3|] ] , 3.0) 
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Int32}},`0)">
<summary>Sets submatrix to scalar value
</summary>
<param name="indexSeqs">Seq of subscript sequences. If only 1 sequence then linear indexing used</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [4;4] : Matrix
x.Set([ {0..2};{1..3} ] , 3.0) 
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
<exception cref="T:System.ArgumentException">Thrown when wrong number of index sequences.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Set(System.Collections.Generic.IEnumerable{System.Int32},`0)">
<summary>Sets submatrix using linear indexing in column major order
</summary>
<param name="indices">Sequence of subscripts</param>
<param name="value">Value to set in submatrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;3;4] : Matrix
x.[{0..2..4}] &lt;- 3.0 // sets 1st, 3rd and 5th element to 3.0
</code>
</example>
<remarks>Subscripts are zero based
</remarks>
<exception cref="T:System.IndexOutOfRangeException">Thrown when index out of range.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Round(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise round
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = round(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Reshape(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Reshapes current instance (in place operation). Dimensions can change but number of elements (length) must stay the same
</summary>
<param name="size">New dimensions</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
x.Reshape([6;4])
let size = x.Size // returns [6;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when reshaped length does not equal original length.</exception>
<exception cref="T:System.ArgumentException">Thrown when new dimensions are invalid, e.g. negative.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Pow(Fmat.Numerics.Matrix{`0,`1},Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise power of matrix
</summary>
<param name="matrix1">Matrix argument</param>
<param name="matrix2">Power</param>
<returns>Elementwise power of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = rand [2;3;4] : Matrix
let z = x ** y
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.Pow(Fmat.Numerics.Matrix{`0,`1},`0)">
<summary>Calculates elementwise power of matrix
</summary>
<param name="matrix">Matrix argument</param>
<param name="a">Power</param>
<returns>Elementwise power of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = x ** 2.0
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.Norminv(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise inverse standard normal cumulative distribution
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise inverse standard normal cumulative distribution function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.norminv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Normcdf(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise standard normal cumulative distribution
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise standard normal cumulative distribution of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.normcdf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Log10(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise log10
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = log10(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Log(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise log
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = log(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Identity(System.Int32,System.Int32)">
<summary>Creates a matrix with diagonal elements set to generic 1 and generic 0 otherwise
</summary>
<param name="rows">Number of rows</param>
<param name="cols">Number of columns</param>
<returns>Matrix with diagonal elements equal 1</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix.Identity(2,3) : Matrix
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when n or m &lt; 0.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>Gets slice of 4D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<param name="start3">Start subscript in 4th dimension. Zero if not specified</param>
<param name="end3">End subscript in 4th dimension. (Length-1) if not specified</param>
<returns>Slice of matrix
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4;5;6] : Matrix
let y = x.[1..2, 2..3, 2..4, 2..5]  
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 4D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>Gets slice of 3D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<param name="start2">Start page. Zero if not specified</param>
<param name="end2">End page. (Length-1) if not specified</param>
<returns>Slice of matrix
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4;5] : Matrix
let y = x.[1..2, 2..3, 2..4]  
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 3D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>Gets slice of 2D matrix
</summary>
<param name="start0">Start row. Zero if not specified</param>
<param name="end0">End row. (Length-1) if not specified</param>
<param name="start1">Start column. Zero if not specified</param>
<param name="end1">End column. (Length-1) if not specified</param>
<returns>Slice of matrix
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [3;4] : Matrix
let y = x.[1..2, 2..3]  
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or end indices out of range.</exception>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>Gets slice of matrix using linear indexing
</summary>
<param name="start">Start linear subscript. Zero if not specified</param>
<param name="finish">End linear subscript. (Length-1) if not specified</param>
<returns>Slice of matrix
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
let y = x.[0..2] // returns first 3 elements
let y = x.[3..] // returns last 3 elements
</code>
</example>
<exception cref="T:System.IndexOutOfRangeException">Thrown when start or finish out of range.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Exp(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise exp
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = exp(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Erfinv(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise inverse error function
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise inverse error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.erfinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Erfcinv(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise inverse complementary error function
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise inverse complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.erfcinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Erfc(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise complementary error function
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.erfc(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Erf(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise error function
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = Matrix.erf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Cosh(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise cosh
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = cosh(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Cos(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise cos
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = cos(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Ceiling(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise ceil
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = ceil(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Atan(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise atan
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = atan(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Asin(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise asin
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = asin(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.ApplyFun(Microsoft.FSharp.Core.FSharpFunc{`0,`0})">
<summary>Applies given function to each element of matrix in place
</summary>
<param name="f">Function to apply elementwise</param>
<returns>(). Input matrix is modified.
</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3] : Matrix
x.ApplyFun(fun x -&gt; x * x) // squares each element
</code>
</example> 
</member>
<member name="M:Fmat.Numerics.Matrix`2.Acos(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise acos
</summary>
<param name="matrix">Matrix argument</param>
<returns>Elementwise sqrt of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] : Matrix
let y = acos(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.Abs(Fmat.Numerics.Matrix{`0,`1})">
<summary>Calculates elementwise absolute value
</summary>
<param name="matrix">Matrix argument</param>
<returns>Absolute value of matrix elementwise</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] - 0.5
let y = abs(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,`0}}}})">
<param name="size">Length of each dimension. Must have 4 dimensions.</param>
<param name="initializer">Function generating a value for dim0..dim3 index</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3;4], (fun i j k l -&gt; float(i) + float(j) + float(k) + float(l)))
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,`0}}})">
<param name="size">Length of each dimension. Must have 3 dimensions.</param>
<param name="initializer">Function generating a value for each row, column and page index</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3;4], (fun i j k -&gt; float(i) + float(j) + float(k)))
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,`0}})">
<param name="size">Length of each dimension. Must have 2 dimensions.</param>
<param name="initializer">Function generating a value for each row and column index</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3], (fun i j -&gt; float(i) + float(j)))
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,`0})">
<param name="size">Length of each dimension</param>
<param name="initializer">Function generating a value for each column major order index i.</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3;4], (fun i -&gt; float(i) + 2.0))
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(Fmat.Numerics.__BoolMatrix)">
<param name="boolMatrix">Boolean matrix object as returned from elementwise comparison</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x1 = Matrix([2;2], 3.0)
let x2 = Matrix([2;2], 4.0)
let y = Matrix(x1 .&lt; x2)
</code>
</example>
<remarks>True is converted to generic 1, False to generic zero. Matrix comparison operators, e.g. ".&lt;" return boolean matrix object __BoolMatrix.
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(`0)">
<param name="data">Scalar value</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix(2.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{`0[]})">
<param name="data">Sequence of values in 2D matrix by rows</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = [ [|1.0..3.0|]
          [|2.0..3.0|]
        ]
let y = Matrix(x)  // returns matrix 2x3
</code>
</example>
<remarks>If rows have different lengths, missing values are set to generic zero
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
<param name="data">Sequence of values in 2D matrix by rows</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = [ {1.0..3.0}
          {2.0..3.0}
        ]
let y = Matrix(x)  // returns matrix 2x3
</code>
</example>
<remarks>If rows have different lengths, missing values are set to generic zero
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{`0}})">
<param name="data">Sequence of values in 2D matrix by rows</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = [ [1.0;2.0;3.0]
          [2.0;3.0]
        ]
let y = Matrix(x)  // returns matrix 2x3
</code>
</example>
<remarks>If rows have different lengths, missing values are set to generic zero
</remarks>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
<param name="data">Sequence of values</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = [1.0..3.0]
let y = Matrix(x)  // returns matrix 1x3
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(`0[0:,0:,0:,0:])">
<param name="data">4D .NET array</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Array4D.create 2 3 2 2 1.0
let y = Matrix(x)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(`0[0:,0:,0:])">
<param name="data">3D .NET array</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Array3D.create 2 3 2 1.0
let y = Matrix(x)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(`0[0:,0:])">
<param name="data">2D .NET array</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Array2D.create 2 3 1.0
let y = new Matrix(x)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},`0)">
<param name="size">Length of each dimension</param>
<param name="init">Scalar value to fill matrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3;4], 2.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{`0})">
<param name="size">Length of each dimension. There must be at least 2 dimensions.</param>
<param name="data">Matrix data in column major order</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
let x = Matrix([2;3;4], [1.0..24.0])
</code>
</example>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.Matrix`2">
<summary>Multidimensional generic matrix.
</summary>
<param name="size">Length of each dimension. There must be at least 2 dimensions.</param>
<param name="data">Matrix data in column major order.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<remarks>Must have at least 2 dimensions. Scalar values are matrices 1x1, vectors are 1xN or Nx1
</remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Fmat.Numerics.Fmat.Numerics.RandStream.Generator@">
<summary>Gets or sets current IRandomGenerator
</summary>
</member>
<member name="P:Fmat.Numerics.RandStream.Generator(Fmat.Numerics.IRandomGenerator)">
<summary>Gets or sets current IRandomGenerator
</summary>
</member>
<member name="P:Fmat.Numerics.RandStream.Generator">
<summary>Gets or sets current IRandomGenerator
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.RandStream">
<summary>Represents a source of pseudorandom numbers
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.__BoolMatrix">
<summary>Boolean dense matrix object returned from elementwise matrix comparison. For internal use only.
</summary>
<remarks>Use BoolMatrix for bool matrix operations.
</remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fmat.Numerics.BasicStat.cov(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates covariance between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<returns>Covariance matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = cov(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.corr(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates correlation between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<returns>Correlation matrix pxp</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = corr(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.quantile(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates quantiles of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="quantiles">Quantiles vector:  Matrix 1xn or nx1</param>
<param name="dim">Dimension along which quantiles will be calculated</param>
<returns>matrix with quantiles</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;30;4] 
let q = Matrix([0.05;0.95])
let y = quantile(x, q, 1) // returns Matrix with size [2;2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified or quantile q not in 0&lt;=q&lt;=1.</exception>
<exception cref="T:System.RankException">Thrown when quantiles not a vector 1xn or nx1.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.kurtosis(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates kurtosis of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which kurtosis will be calculated</param>
<returns>matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = kurtosis(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.skewness(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates skewness of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which skewness will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = skewness(x, 1) // returns Matrix with size [2;1;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.var(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates variance of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which variance will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = var(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.mean(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates mean of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which mean will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = mean(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.cumprod(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates cumulative product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative product will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = cumprod(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
<exception cref="T:System.OutOfMemoryException">Thrown when not enough memory available.</exception>
<exception cref="T:System.ObjectDisposedException">Thrown when matrix has been disposed with Dispose().</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.cumsum(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates cumulative sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative sum will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = cumsum(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.prod(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which product will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = prod(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.sum(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which sum will be calculated</param>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = sum(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.max(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = max(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.min(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = min(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.poissRnd(System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Poisson distributed random numbers
</summary>
<param name="lambda">Lambda</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = poissRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or lambda negative.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.binomRnd(System.Int32,System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with binomial distributed random numbers
</summary>
<param name="n">Number of trials</param>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = binomRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1 or n &lt;0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.bernRnd(System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Bernoulli distributed random numbers
</summary>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = bernRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.mvNormRnd(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Generates matrix with multivariate normal distribution
</summary>
<param name="mean">Vector kx1 or 1xk of means</param>
<param name="cov">Covariance matrix kxk</param>
<param name="n">Number of k-dimensional vectors to generate. Vectors are returned in rows of result matrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let mn = !![2.345;2.345]
let cv = !![ [1.;1.]
             [1.;2.] ]
let m = mvNormRnd(mn, cv, 10) // returns matrix 10x2 
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or cov matrix not pos definite or incompatible size.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.lognormRnd(System.Double,System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with lognormal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="a">Displacement</param>
<param name="scale">Scale</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = lognormRnd(0.0, 1.0, 0.0, 1.0, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.normalRnd(System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with normal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = normRnd(0.0, 1.0, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.unifRnd(System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [a, b] 
</summary>
<param name="a">Lower endpoint</param>
<param name="b">Upper endpoint</param>
<param name="size">Dimensions of the matrix to be generated</param>
<returns>Matrix with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = unifRnd(0.0, 1.0, [2;3;4])
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or b &lt;= a.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat.rand(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [0, 1] 
</summary>
<param name="size">Dimensions of the matrix to be generated</param>
<returns>Matrix with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4]
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified.</exception>
</member>
<member name="T:Fmat.Numerics.BasicStat">
<summary>This module contains functions for random number generation and calculating basic stats in double precision
</summary>
</member>
<member name="M:Fmat.Numerics.BasicStat32.cov(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates covariance between 2D matrix columns
</summary>
<param name="matrix">2D Matrix32 argument [nxp], with n observations and p variables</param>
<returns>Covariance matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [10;3] //10 observations, 3 variables
let y = cov(x) // returns Matrix32 with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.corr(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates correlation between 2D matrix columns
</summary>
<param name="matrix">2D Matrix32 argument [nxp], with n observations and p variables</param>
<returns>Correlation matrix pxp</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [10;3] //10 observations, 3 variables
let y = corr(x) // returns Matrix32 with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.quantile(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates quantiles of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="quantiles">Quantiles vector:  Matrix32 1xn or nx1</param>
<param name="dim">Dimension along which quantiles will be calculated</param>
<returns>matrix with quantiles</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;30;4] 
let q = Matrix32([0.05;0.95])
let y = quantile(x, q, 1) // returns Matrix32 with size [2;2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified or quantile q not in 0&lt;=q&lt;=1.</exception>
<exception cref="T:System.RankException">Thrown when quantiles not a vector 1xn or nx1.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.kurtosis(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates kurtosis of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which kurtosis will be calculated</param>
<returns>matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = kurtosis(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.skewness(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates skewness of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which skewness will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = skewness(x, 1) // returns Matrix32 with size [2;1;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.var(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates variance of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which variance will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = var(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.mean(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates mean of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which mean will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = mean(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.cumprod(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates cumulative product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which cumulative product will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = cumprod(x, 1) // returns Matrix32 with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
<exception cref="T:System.OutOfMemoryException">Thrown when not enough memory available.</exception>
<exception cref="T:System.ObjectDisposedException">Thrown when matrix has been disposed with Dispose().</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.cumsum(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates cumulative sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which cumulative sum will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = cumsum(x, 1) // returns Matrix32 with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.prod(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which product will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = prod(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.sum(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which sum will be calculated</param>
<returns>Matrix32 with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = sum(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.max(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix32 with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = max(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.min(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix32 argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<returns>Matrix32 with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = min(x, 1) // returns Matrix32 with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.poissRnd(System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Poisson distributed random numbers
</summary>
<param name="lambda">Lambda</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = poissRnd(0.5f, [2;3;4])
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or lambda negative.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.binomRnd(System.Int32,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with binomial distributed random numbers
</summary>
<param name="n">Number of trials</param>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = binomRnd(0.5f, [2;3;4])
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1 or n &lt;0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.bernRnd(System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Bernoulli distributed random numbers
</summary>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = bernRnd(0.5f, [2;3;4])
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.mvNormRnd(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Generates matrix with multivariate normal distribution
</summary>
<param name="mean">Vector kx1 or 1xk of means</param>
<param name="cov">Covariance matrix kxk</param>
<param name="n">Number of k-dimensional vectors to generate. Vectors are returned in rows of result matrix</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let mn = !![2.345f;2.345f]
let cv = !![ [1.f;1.f]
             [1.f;2.f] ]
let m = mvNormRnd(mn, cv, 10) // returns matrix 10x2 
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or cov matrix not pos definite or incompatible size.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.lognormRnd(System.Single,System.Single,System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with lognormal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="a">Displacement</param>
<param name="scale">Scale</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = lognormRnd(0.0f, 1.0f, 0.0f, 1.0f, [2;3;4])
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.normalRnd(System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with normal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="size">Dimensions of the matrix to be generated</param>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = normRnd(0.0f, 1.0f, [2;3;4])
</code>
</example>
<returns>Matrix32 with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.unifRnd(System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [a, b] 
</summary>
<param name="a">Lower endpoint</param>
<param name="b">Upper endpoint</param>
<param name="size">Dimensions of the matrix to be generated</param>
<returns>Matrix32 with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = unifRnd(0.0f, 1.0f, [2;3;4])
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or b &lt;= a.</exception>
</member>
<member name="M:Fmat.Numerics.BasicStat32.rand(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [0, 1] 
</summary>
<param name="size">Dimensions of the matrix to be generated</param>
<returns>Matrix32 with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4]
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified.</exception>
</member>
<member name="T:Fmat.Numerics.BasicStat32">
<summary>This module contains functions for random number generation and calculating basic stats in single precision
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.BoolMatrixOps">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.ComparableMatrixOps">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.Conversion">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.Distributions">

</member>
<member name="M:Fmat.Numerics.GenericBasicStat.cov``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates covariance between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Covariance matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = cov(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.corr``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates correlation between 2D matrix columns
</summary>
<param name="matrix">2D Matrix argument [nxp], with n observations and p variables</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Correlation matrix pxp</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [10;3] //10 observations, 3 variables
let y = corr(x) // returns Matrix with size [3;3]
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.quantile``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates quantiles of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="quantiles">Quantiles vector:  Matrix 1xn or nx1</param>
<param name="dim">Dimension along which quantiles will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>matrix with quantiles</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;30;4] : Matrix
let q = Matrix([0.05;0.95])
let y = quantile(x, q, 1) // returns Matrix with size [2;2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified or quantile q not in 0&lt;=q&lt;=1.</exception>
<exception cref="T:System.RankException">Thrown when quantiles not a vector 1xn or nx1.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.kurtosis``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates kurtosis of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which kurtosis will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = kurtosis(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.skewness``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates skewness of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which skewness will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = skewness(x, 1) // returns Matrix with size [2;1;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.var``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates variance of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which variance will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = var(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.mean``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates mean of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which mean will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = mean(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.cumprod``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates cumulative product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative product will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = cumprod(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
<exception cref="T:System.OutOfMemoryException">Thrown when not enough memory available.</exception>
<exception cref="T:System.ObjectDisposedException">Thrown when matrix has been disposed with Dispose().</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.cumsum``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates cumulative sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which cumulative sum will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = cumsum(x, 1) // returns Matrix with size [2;3;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.prod``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates product of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which product will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = prod(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.sum``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates sum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which sum will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with summarized data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = sum(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.max``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = max(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.min``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Calculates minimum of matrix elements along given dimension
</summary>
<param name="matrix">Matrix argument</param>
<param name="dim">Dimension along which minimum will be calculated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with reduced data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
let y = min(x, 1) // returns Matrix with size [2;4]
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.poissRnd``2(``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Poisson distributed random numbers
</summary>
<param name="lambda">Lambda</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = poissRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or lambda negative.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.binomRnd``2(System.Int32,``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with binomial distributed random numbers
</summary>
<param name="n">Number of trials</param>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = binomRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1 or n &lt;0.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.bernRnd``2(``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with Bernoulli distributed random numbers
</summary>
<param name="p">Probability of success</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = bernRnd(0.5, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or p not between 0 and 1.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.mvNormRnd``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Generates matrix with multivariate normal distribution
</summary>
<param name="mean">Vector kx1 or 1xk of means</param>
<param name="cov">Covariance matrix kxk</param>
<param name="n">Number of k-dimensional vectors to generate. Vectors are returned in rows of result matrix</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let mn = !![2.345;2.345]
let cv = !![ [1.;1.]
             [1.;2.] ]
let m = mvNormRnd(mn, cv, 10) // returns matrix 10x2 
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or cov matrix not pos definite or incompatible size.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.lognormRnd``2(``0,``0,``0,``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with lognormal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="a">Displacement</param>
<param name="scale">Scale</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = lognormRnd(0.0, 1.0, 0.0, 1.0, [2;3;4])
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.normalRnd``2(``0,``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with normal random numbers
</summary>
<param name="mu">Mean</param>
<param name="sigma">Standard deviation</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = normRnd(0.0, 1.0, [2;3;4]) : Matrix
</code>
</example>
<returns>Matrix with random data</returns>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or sigma &lt;= 0.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.unifRnd``2(``0,``0,System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [a, b] 
</summary>
<param name="a">Lower endpoint</param>
<param name="b">Upper endpoint</param>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = unifRnd(0.0, 1.0, [2;3;4]) : Matrix
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified or b &lt;= a.</exception>
</member>
<member name="M:Fmat.Numerics.GenericBasicStat.rand``2(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Generates matrix with continuous uniform random numbers in [0, 1] 
</summary>
<param name="size">Dimensions of the matrix to be generated</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with random data</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] : Matrix
</code>
</example>
<remarks>The sequence is determined by RandStream settings
</remarks>
<exception cref="T:System.ArgumentException">Thrown when invalid dims are specified.</exception>
</member>
<member name="T:Fmat.Numerics.GenericBasicStat">
<summary>This module contains generic functions for random number generation and calculating basic stats
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.GenericFloatTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.GenericFormatting">

</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.svd``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Performs singular value factorization
</summary>
<param name="matrix">Input matrix.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>(U, S, Vt) matrices, S is vector of singular values, Vt is transposed V </returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let x = rand [20;10] : Matrix
let (u, s, vt) = svd(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when algorithm did not converge.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.svdSolve``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},``0)">
<summary>Finds least squares solution of linear equation using singular value factorization with given tolerance
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<param name="tol">Tolerance to determine rank of A.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let a = rand [2;2] : Matrix
let b = rand [2;1]
let x = svdSolve(a, b, 1e-10)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Try different tolerance.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.qrSolveFull``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1})">
<summary>Finds least squares solution of linear equation using QR factorization assuming full rank
</summary>
<param name="a">A in equation Ax=b. Must have full rank</param>
<param name="b">b in equation Ax=b.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let a = rand [2;2] : Matrix
let b = rand [2;1]
let x = qrSolveFull(a, b)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Matrix does not have full rank</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.qr``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Performs QR factorization
</summary>
<param name="matrix">Input matrix.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>(Q, R) matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let x = rand [20;10] : Matrix
let (q, r) = qr(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when factorization failed.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.luSolve``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1})">
<summary>Solves linear equation using LU factorization
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let a = rand [2;2] : Matrix
let b = rand [2;1]
let x = luSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D square or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.lu``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Performs LU factorization
</summary>
<param name="matrix">Input matrix.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>(L, U, P) Lower/Upper matrices, P is a vector with row permutations</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let x = rand [20;10] : Matrix
let (l, u, p) = lu(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.cholSolve``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1})">
<summary>Solves linear equation using chol factorization
</summary>
<param name="a">A in equation Ax=b. Must be positive definite.</param>
<param name="b">b in equation Ax=b.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericLinearAlgebra
let a = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let b = rand [2;1]
let x = cholSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not square or A and B have non compatible dimensions.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix A not positive definite.</exception>
</member>
<member name="M:Fmat.Numerics.GenericLinearAlgebra.chol``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Performs cholesky factorization
</summary>
<param name="matrix">Input matrix. Must be positive definite.</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Upper triangular matrix calculated in factorization</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericLinearAlgebra
let x = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let y = chol(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix not positive definite.</exception>
</member>
<member name="T:Fmat.Numerics.GenericLinearAlgebra">
<summary>This module contains generic functions for matrix linear algebra
</summary>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.norminv``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise inverse standard normal cumulative distribution
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise inverse standard normal cumulative distribution function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = norminv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.normcdf``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise standard normal cumulative distribution
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise standard normal cumulative distribution of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = normcdf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.erfcinv``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise inverse complementary error function
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise inverse complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = erfcinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.erfinv``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise inverse error function
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise inverse error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = erfinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.erfc``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise complementary error function
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = erfc(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.erf``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Calculates elementwise error function
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
let x = rand [2;3;4] 
let y = erf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.applyFun3Arg``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}})">
<summary>Applies given function elementwise to 3 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="z">Third matrix</param>
<param name="f">Elementwise function of 3 args</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>New matrix as elementwise transformation of 3 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x1 = rand [3;4] : Matrix
let x2 = rand [3;4]
let x3 = rand [3;4]
let y = applyFun3Arg(x1, x2, x3, fun x1 x2 x3 -&gt; x1 + x2 + x3)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.applyFun2Arg``2(Fmat.Numerics.Matrix{``0,``1},Fmat.Numerics.Matrix{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>Applies given function elementwise to 2 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="f">Elementwise function of 2 args</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>New matrix as elementwise transformation of 2 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x1 = rand [3;4] : Matrix
let x2 = rand [3;4]
let y = applyFun2Arg(x1, x2, fun x1 x2 -&gt; x1 + x2)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.applyFun``2(Fmat.Numerics.Matrix{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>Applies given function elementwise to a matrix. New matrix is returned. Input matrix is not modified.
</summary>
<param name="x">Input matrix</param>
<param name="f">Elementwise function</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>New matrix as elementwise transformation of input matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [3;4] : Matrix
let y = applyFun(x, fun x -&gt; x + 1.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.maxXY``4(``0,``3)">
<summary>Calculates elementwise maximum of 2 arguments. Each argument can be scalar of type 'T or Matrix with elements of type 'T
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise maximum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [2;3;4] : Matrix
let y = rand [2;3;4] : Matrix
let z = maxXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.minXY``4(``0,``3)">
<summary>Calculates elementwise minimum of 2 arguments. Each argument can be scalar of type 'T or Matrix with elements of type 'T
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise minimum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [2;3;4]
let y = rand [2;3;4]
let z = minXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.transpose``2(Fmat.Numerics.Matrix{``0,``1})">
<summary>Transposes matrix
</summary>
<param name="matrix">Input matrix</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Transposed matrix. Input matrix does not change</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [3;4] : Matrix
let y = transpose(x) // returns matrix 4x3
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.reshape``2(Fmat.Numerics.Matrix{``0,``1},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Reshapes matrix. Number of elements must not change.
</summary>
<param name="matrix">Input matrix</param>
<param name="size">New size</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Reshaped matrix. Input matrix is not changed</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [3;4] : Matrix
let y = reshape(x, [3;2;2]) // returns matrix 3x2x2
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when new size is invalid or length is different.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.repmat``2(Fmat.Numerics.Matrix{``0,``1},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Replicates matrix in each dimension
</summary>
<param name="matrix">Input matrix</param>
<param name="replicator">Array of replicators, one for each dimension</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Replicated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [2;3;5] : Matrix
let y = repmat(x, [2;3;1] // returns matrix 4x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when replicator has less than 2 elements or negative element.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.vertConcat``2(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{``0,``1}})">
<summary>Concatenates matrices along dimension 0
</summary>
<param name="matrices">Sequence of matrices</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x1 = rand [2;2;5 : Matrix
let x2 = rand [3;2;5]
let x3 = rand [4;2;5]
let y = vertConcat([x1;x2;x3]) // returns matrix 9x2x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.horzConcat``2(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{``0,``1}})">
<summary>Concatenates matrices along dimension 1
</summary>
<param name="matrices">Sequence of matrices</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x1 = rand [3;2;5] : Matrix
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = horzConcat([x1;x2;x3]) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.concat``2(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{``0,``1}},System.Int32)">
<summary>Concatenates matrices along given dimension
</summary>
<param name="matrices">Sequence of matrices</param>
<param name="dimension">Dimension</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x1 = rand [3;2;5] : Matrix
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = concat([x1;x2;x3], 1) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.triU``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Extracts upper triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Upper triangular matrix down to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [3;4] : Matrix
let y = triU(x, -1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.triL``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Extracts lower triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Lower triangular matrix up to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericBasicStat
open Fmat.Numerics.GenericMatrixFunctions
let x = rand [3;4] : Matrix
let y = triL(x, 1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.diag``2(Fmat.Numerics.Matrix{``0,``1},System.Int32)">
<summary>Creates diagonal matrix based on given vector (matrix 1xN or Nx1)
</summary>
<param name="vector">Values to store in diagonal</param>
<param name="offset">Offset. Positive to store values above main digonal</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with k-th diagonal set to given vector</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericMatrixFunctions
let v = !![[1.;2.;3.]]
let x = diag(x, 1)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when offset too big.</exception>
<exception cref="T:System.RankException">Thrown when not vector.</exception>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.ones``2(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic one
</summary>
<param name="size">Size of matrix</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericMatrixFunctions
let x = ones [2;3;4] : Matrix
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.zeros``2(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic zero
</summary>
<param name="size">Size of matrix</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Matrix with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.GenericMatrixFunctions
let x = zeros [2;3;4] : Matrix
</code>
</example>
</member>
<member name="M:Fmat.Numerics.GenericMatrixFunctions.I``2(System.Int32,System.Int32)">
<summary>Creates matrix with diagonal elements set to generic 1 and generic 0 otherwise.
</summary>
<param name="n">Number of rows</param>
<param name="m">Number of columns</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Diagonal matrix.</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics.GenericMatrixFunctions
let x = I(2,3) : Matrix
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when n or m &lt; 0.</exception>
</member>
<member name="T:Fmat.Numerics.GenericMatrixFunctions">
<summary>This module contains generic functions for matrix manipulation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.GenericMatrixOps">

</member>
<member name="M:Fmat.Numerics.LinearAlgebra.svd(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Performs singular value factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(U, S, Vt) matrices, S is vector of singular values, Vt is transposed V </returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let x = rand [20;10]
let (u, s, vt) = svd(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when algorithm did not converge.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.svdSolve(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Double)">
<summary>Finds least squares solution of linear equation using singular value factorization with given tolerance
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<param name="tol">Tolerance to determine rank of A.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let a = rand [2;2]
let b = rand [2;1]
let x = svdSolve(a, b, 1e-10)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Try different tolerance.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.qrSolveFull(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Finds least squares solution of linear equation using QR factorization assuming full rank
</summary>
<param name="a">A in equation Ax=b. Must have full rank</param>
<param name="b">b in equation Ax=b.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let a = rand [2;2]
let b = rand [2;1]
let x = qrSolveFull(a, b)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Matrix does not have full rank</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.qr(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Performs QR factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(Q, R) matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let x = rand [20;10]
let (q, r) = qr(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when factorization failed.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.luSolve(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Solves linear equation using LU factorization
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let a = rand [2;2]
let b = rand [2;1]
let x = luSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D square or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.lu(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Performs LU factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(L, U, P) Lower/Upper matrices, P is a vector with row permutations</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let x = rand [20;10]
let (l, u, p) = lu(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.cholSolve(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Solves linear equation using chol factorization
</summary>
<param name="a">A in equation Ax=b. Must be positive definite.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.LinearAlgebra
let a = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let b = rand [2;1]
let x = cholSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not square or A and B have non compatible dimensions.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix A not positive definite.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra.chol(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Performs cholesky factorization
</summary>
<param name="matrix">Input matrix. Must be positive definite.</param>
<returns>Upper triangular matrix calculated in factorization</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.LinearAlgebra
let x = Matrix([ [1.0;0.5]
                 [0.5;1.0] ]
let y = chol(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix not positive definite.</exception>
</member>
<member name="T:Fmat.Numerics.LinearAlgebra">
<summary>This module contains functions for double precision matrix linear algebra
</summary>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.svd(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Performs singular value factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(U, S, Vt) matrices, S is vector of singular values, Vt is transposed V </returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let x = rand [20;10]
let (u, s, vt) = svd(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when algorithm did not converge.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.svdSolve(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Single)">
<summary>Finds least squares solution of linear equation using singular value factorization with given tolerance
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<param name="tol">Tolerance to determine rank of A.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let a = rand [2;2]
let b = rand [2;1]
let x = svdSolve(a, b, 1e-10)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Try different tolerance.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.qrSolveFull(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Finds least squares solution of linear equation using QR factorization assuming full rank
</summary>
<param name="a">A in equation Ax=b. Must have full rank</param>
<param name="b">b in equation Ax=b.</param>
<returns>Least squares solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let a = rand [2;2]
let b = rand [2;1]
let x = qrSolveFull(a, b)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found. Matrix32 does not have full rank</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.qr(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Performs QR factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(Q, R) matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let x = rand [20;10]
let (q, r) = qr(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when factorization failed.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.luSolve(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Solves linear equation using LU factorization
</summary>
<param name="a">A in equation Ax=b.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let a = rand [2;2]
let b = rand [2;1]
let x = luSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not 2D square or B not equal number of rows as A.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when solution cannot be found.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.lu(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Performs LU factorization
</summary>
<param name="matrix">Input matrix.</param>
<returns>(L, U, P) Lower/Upper matrices, P is a vector with row permutations</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let x = rand [20;10]
let (l, u, p) = lu(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.cholSolve(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Solves linear equation using chol factorization
</summary>
<param name="a">A in equation Ax=b. Must be positive definite.</param>
<param name="b">b in equation Ax=b.</param>
<returns>Solution of Ax=b</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.LinearAlgebra32
let a = Matrix32([ [1.0f;0.5f]
                   [0.5f;1.0f] ]
let b = rand [2;1]
let x = cholSolve(a, b) // ax=b
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when matrix A not square or A and B have non compatible dimensions.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix A not positive definite.</exception>
</member>
<member name="M:Fmat.Numerics.LinearAlgebra32.chol(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Performs cholesky factorization
</summary>
<param name="matrix">Input matrix. Must be positive definite.</param>
<returns>Upper triangular matrix calculated in factorization</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.LinearAlgebra32
let x = Matrix32([ [1.0f;0.5f]
                   [0.5f;1.0f] ]
let y = chol(x)
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2D.</exception>
<exception cref="T:System.ArgumentException">Thrown when matrix not symmetrical.</exception>
<exception cref="T:System.InvalidOperationException">Thrown when matrix not positive definite.</exception>
</member>
<member name="T:Fmat.Numerics.LinearAlgebra32">
<summary>This module contains functions for single precision matrix linear algebra
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.LinearAlgebraOps">

</member>
<member name="M:Fmat.Numerics.Matrix32Functions.norminv(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise inverse standard normal cumulative distribution
</summary>
<param name="x">Matrix32 argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise inverse standard normal cumulative distribution function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = norminv(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.normcdf(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise standard normal cumulative distribution
</summary>
<param name="x">Matrix32 argument</param>
<returns>Elementwise standard normal cumulative distribution of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = normcdf(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.erfcinv(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise inverse complementary error function
</summary>
<param name="x">Matrix32 argument</param>
<returns>Elementwise inverse complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = erfcinv(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.erfinv(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise inverse error function
</summary>
<param name="x">Matrix32 argument</param>
<returns>Elementwise inverse error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = erfinv(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.erfc(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise complementary error function
</summary>
<param name="x">Matrix32 argument</param>
<returns>Elementwise complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = erfc(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.erf(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise error function
</summary>
<param name="x">Matrix32 argument</param>
<returns>Elementwise error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
let x = rand [2;3;4] 
let y = erf(x) // returns Matrix32 with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.applyFun3Arg(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Microsoft.FSharp.Core.FSharpFunc{System.Single,Microsoft.FSharp.Core.FSharpFunc{System.Single,Microsoft.FSharp.Core.FSharpFunc{System.Single,System.Single}}})">
<summary>Applies given function elementwise to 3 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="z">Third matrix</param>
<param name="f">Elementwise function of 3 args</param>
<returns>New matrix as elementwise transformation of 3 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x1 = rand [3;4] 
let x2 = rand [3;4]
let x3 = rand [3;4]
let y = applyFun3Arg(x1, x2, x3, fun x1 x2 x3 -&gt; x1 + x2 + x3)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.applyFun2Arg(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Microsoft.FSharp.Core.FSharpFunc{System.Single,Microsoft.FSharp.Core.FSharpFunc{System.Single,System.Single}})">
<summary>Applies given function elementwise to 2 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="f">Elementwise function of 2 args</param>
<returns>New matrix as elementwise transformation of 2 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x1 = rand [3;4]
let x2 = rand [3;4]
let y = applyFun2Arg(x1, x2, fun x1 x2 -&gt; x1 + x2)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.applyFun(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Microsoft.FSharp.Core.FSharpFunc{System.Single,System.Single})">
<summary>Applies given function elementwise to a matrix. New matrix is returned. Input matrix is not modified.
</summary>
<param name="x">Input matrix</param>
<param name="f">Elementwise function</param>
<returns>New matrix as elementwise transformation of input matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [3;4] 
let y = applyFun(x, fun x -&gt; x + 1.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.maxXY(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise maximum of 2 arguments. Each argument can be scalar of float32 or Matrix32
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<returns>Elementwise maximum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [2;3;4] 
let y = rand [2;3;4] 
let z = maxXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.minXY(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Calculates elementwise minimum of 2 arguments. Each argument can be scalar of type float32 or Matrix32
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<returns>Elementwise minimum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [2;3;4]
let y = rand [2;3;4]
let z = minXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.transpose(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib})">
<summary>Transposes matrix
</summary>
<param name="matrix">Input matrix</param>
<returns>Transposed matrix. Input matrix does not change</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [3;4] 
let y = transpose(x) // returns matrix 4x3
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.reshape(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Reshapes matrix. Number of elements must not change.
</summary>
<param name="matrix">Input matrix</param>
<param name="size">New size</param>
<returns>Reshaped matrix. Input matrix is not changed</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [3;4]
let y = reshape(x, [3;2;2]) // returns matrix 3x2x2
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when new size is invalid or length is different.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.repmat(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Replicates matrix in each dimension
</summary>
<param name="matrix">Input matrix</param>
<param name="replicator">Array of replicators, one for each dimension</param>
<returns>Replicated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [2;3;5]
let y = repmat(x, [2;3;1] // returns matrix 4x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when replicator has less than 2 elements or negative element.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.vertConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib}})">
<summary>Concatenates matrices along dimension 0
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x1 = rand [2;2;5
let x2 = rand [3;2;5]
let x3 = rand [4;2;5]
let y = vertConcat([x1;x2;x3]) // returns matrix 9x2x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.horzConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib}})">
<summary>Concatenates matrices along dimension 1
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x1 = rand [3;2;5]
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = horzConcat([x1;x2;x3]) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.concat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib}},System.Int32)">
<summary>Concatenates matrices along given dimension
</summary>
<param name="matrices">Sequence of matrices</param>
<param name="dimension">Dimension</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x1 = rand [3;2;5] 
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = concat([x1;x2;x3], 1) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.triU(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Extracts upper triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<returns>Upper triangular matrix down to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [3;4]
let y = triU(x, -1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.triL(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Extracts lower triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<returns>Lower triangular matrix up to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat32
open Fmat.Numerics.Matrix32Functions
let x = rand [3;4]
let y = triL(x, 1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.diag(Fmat.Numerics.Matrix{System.Single,Fmat.Numerics.Float32Lib},System.Int32)">
<summary>Creates diagonal matrix based on given vector (matrix 1xN or Nx1)
</summary>
<param name="vector">Values to store in diagonal</param>
<param name="offset">Offset. Positive to store values above main digonal</param>
<returns>Matrix32 with k-th diagonal set to given vector</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.Matrix32Functions
let v = !![[1.;2.;3.]]
let x = diag(x, 1)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when offset too big.</exception>
<exception cref="T:System.RankException">Thrown when not vector.</exception>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.ones(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic one
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix32 with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.Matrix32Functions
let x = ones [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.zeros(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic zero
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix32 with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.Matrix32Functions
let x = zeros [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.Matrix32Functions.I(System.Int32,System.Int32)">
<summary>Creates matrix with diagonal elements set to generic 1 and generic 0 otherwise.
</summary>
<param name="n">Number of rows</param>
<param name="m">Number of columns</param>
<returns>Diagonal matrix.</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics.Matrix32Functions
let x = I(2,3) 
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when n or m &lt; 0.</exception>
</member>
<member name="T:Fmat.Numerics.Matrix32Functions">
<summary>This module contains functions for manipulation of single precision matrices
</summary>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.norminv(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise inverse standard normal cumulative distribution
</summary>
<param name="x">Matrix argument</param>
<typeparam name="T">Type of matrix elements</typeparam>
<typeparam name="S">Type of matrix operations interface</typeparam>
<returns>Elementwise inverse standard normal cumulative distribution function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = norminv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.normcdf(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise standard normal cumulative distribution
</summary>
<param name="x">Matrix argument</param>
<returns>Elementwise standard normal cumulative distribution of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = normcdf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.erfcinv(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise inverse complementary error function
</summary>
<param name="x">Matrix argument</param>
<returns>Elementwise inverse complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = erfcinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.erfinv(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise inverse error function
</summary>
<param name="x">Matrix argument</param>
<returns>Elementwise inverse error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = erfinv(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.erfc(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise complementary error function
</summary>
<param name="x">Matrix argument</param>
<returns>Elementwise complementary error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = erfc(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.erf(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise error function
</summary>
<param name="x">Matrix argument</param>
<returns>Elementwise error function of matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
let x = rand [2;3;4] 
let y = erf(x) // returns Matrix with size [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.applyFun3Arg(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}}})">
<summary>Applies given function elementwise to 3 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="z">Third matrix</param>
<param name="f">Elementwise function of 3 args</param>
<returns>New matrix as elementwise transformation of 3 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x1 = rand [3;4] 
let x2 = rand [3;4]
let x3 = rand [3;4]
let y = applyFun3Arg(x1, x2, x3, fun x1 x2 x3 -&gt; x1 + x2 + x3)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.applyFun2Arg(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Microsoft.FSharp.Core.FSharpFunc{System.Double,Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double}})">
<summary>Applies given function elementwise to 2 matrices. New matrix is returned. Input matrices are not modified and must have the same size.
</summary>
<param name="x">First matrix</param>
<param name="y">Second matrix</param>
<param name="f">Elementwise function of 2 args</param>
<returns>New matrix as elementwise transformation of 2 input matrices</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x1 = rand [3;4]
let x2 = rand [3;4]
let y = applyFun2Arg(x1, x2, fun x1 x2 -&gt; x1 + x2)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.applyFun(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Microsoft.FSharp.Core.FSharpFunc{System.Double,System.Double})">
<summary>Applies given function elementwise to a matrix. New matrix is returned. Input matrix is not modified.
</summary>
<param name="x">Input matrix</param>
<param name="f">Elementwise function</param>
<returns>New matrix as elementwise transformation of input matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [3;4] 
let y = applyFun(x, fun x -&gt; x + 1.0)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.maxXY(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise maximum of 2 arguments. Each argument can be scalar of float or Matrix
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<returns>Elementwise maximum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [2;3;4] 
let y = rand [2;3;4] 
let z = maxXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.minXY(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Calculates elementwise minimum of 2 arguments. Each argument can be scalar of type float or Matrix
</summary>
<param name="x">First argument</param>
<param name="y">Second argument</param>
<typeparam name="a">Type of first argument</typeparam>
<typeparam name="b">Type of second argument</typeparam>
<returns>Elementwise minimum of x and y</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [2;3;4]
let y = rand [2;3;4]
let z = minXY(x, y)
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.transpose(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib})">
<summary>Transposes matrix
</summary>
<param name="matrix">Input matrix</param>
<returns>Transposed matrix. Input matrix does not change</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [3;4] 
let y = transpose(x) // returns matrix 4x3
</code>
</example>
<exception cref="T:System.RankException">Thrown when matrix not 2 dimensional.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.reshape(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Reshapes matrix. Number of elements must not change.
</summary>
<param name="matrix">Input matrix</param>
<param name="size">New size</param>
<returns>Reshaped matrix. Input matrix is not changed</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [3;4]
let y = reshape(x, [3;2;2]) // returns matrix 3x2x2
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when new size is invalid or length is different.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.repmat(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Replicates matrix in each dimension
</summary>
<param name="matrix">Input matrix</param>
<param name="replicator">Array of replicators, one for each dimension</param>
<returns>Replicated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [2;3;5]
let y = repmat(x, [2;3;1] // returns matrix 4x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when replicator has less than 2 elements or negative element.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.vertConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib}})">
<summary>Concatenates matrices along dimension 0
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x1 = rand [2;2;5
let x2 = rand [3;2;5]
let x3 = rand [4;2;5]
let y = vertConcat([x1;x2;x3]) // returns matrix 9x2x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.horzConcat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib}})">
<summary>Concatenates matrices along dimension 1
</summary>
<param name="matrices">Sequence of matrices</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x1 = rand [3;2;5]
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = horzConcat([x1;x2;x3]) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.concat(System.Collections.Generic.IEnumerable{Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib}},System.Int32)">
<summary>Concatenates matrices along given dimension
</summary>
<param name="matrices">Sequence of matrices</param>
<param name="dimension">Dimension</param>
<returns>Concatenated matrix</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x1 = rand [3;2;5] 
let x2 = rand [3;3;5]
let x3 = rand [3;4;5]
let y = concat([x1;x2;x3], 1) // returns matrix 3x9x5
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when not all dimensions are equal except specified dimension.</exception>
<exception cref="T:System.ArgumentException">Thrown when invalid dimension specified.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.triU(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Extracts upper triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<returns>Upper triangular matrix down to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [3;4]
let y = triU(x, -1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.triL(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Extracts lower triangular matrix
</summary>
<param name="matrix">Input matrix</param>
<param name="k">Offset. Specifies which diagonal should be included</param>
<returns>Lower triangular matrix up to k-th diagonal</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.BasicStat
open Fmat.Numerics.MatrixFunctions
let x = rand [3;4]
let y = triL(x, 1)
</code>
</example>
<exception cref="T:System.RankException">Thrown when not 2D matrix.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.diag(Fmat.Numerics.Matrix{System.Double,Fmat.Numerics.FloatLib},System.Int32)">
<summary>Creates diagonal matrix based on given vector (matrix 1xN or Nx1)
</summary>
<param name="vector">Values to store in diagonal</param>
<param name="offset">Offset. Positive to store values above main digonal</param>
<returns>Matrix with k-th diagonal set to given vector</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.MatrixFunctions
let v = !![[1.;2.;3.]]
let x = diag(x, 1)
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when offset too big.</exception>
<exception cref="T:System.RankException">Thrown when not vector.</exception>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.ones(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic one
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.MatrixFunctions
let x = ones [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.zeros(System.Collections.Generic.IEnumerable{System.Int32})">
<summary>Creates a matrix of given size and sets all elements to generic zero
</summary>
<param name="size">Size of matrix</param>
<returns>Matrix with all elements equal zero</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics
open Fmat.Numerics.MatrixFunctions
let x = zeros [2;3;4]
</code>
</example>
</member>
<member name="M:Fmat.Numerics.MatrixFunctions.I(System.Int32,System.Int32)">
<summary>Creates matrix with diagonal elements set to generic 1 and generic 0 otherwise.
</summary>
<param name="n">Number of rows</param>
<param name="m">Number of columns</param>
<returns>Diagonal matrix.</returns>
<example>Code example:
<code lang="F#">
open Fmat.Numerics.MatrixFunctions
let x = I(2,3) 
</code>
</example>
<exception cref="T:System.ArgumentException">Thrown when n or m &lt; 0.</exception>
</member>
<member name="T:Fmat.Numerics.MatrixFunctions">
<summary>This module contains functions for manipulation of double precision matrices
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.MatrixUtil">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.NumericLiteralG">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.NumericMatrixOps">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.SpecialFunctions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.StatFunctions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.SymmetricOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fmat.Numerics.Validation">

</member>
</members>
</doc>
